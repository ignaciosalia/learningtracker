Introduction to React
(still not shure about this part of freecodecamp I think need some updating)

What is?
Is a JavaScript library for building user interfaces, that are resusable and component-driven.

How it works?
Combining HTML and JAvascript in ist own mark up language calle JSX, Reacto also simplify the flow of data throughout the application


1.- Para usar React y JSX es necesario convertir su codigo a codigo JavaScript valido usando alguna herramienta como BABEL (un 
transpiler) para estos ejemplos las aplicaciones est[an llamando ReactDOM.render(JSX, document.getElementById('root'))
	Agregar elementos usando JSX:
const JSX = <h1>Hello JSX!</h1>; Agrega un titulo de peso H1

2.- Crear elementos complejos JSX
	Para hacer esto se usa anidaci[on, pero con la regla que estos elementos s[olo deben regresar un valor, para hacerlo
	se tiene un s[olo padre del que todos los dem[as elementos son parte, por ejemplo todos los elementos debe un blog
	deben pertencer dentro de un <div>
const JSX = <div>
    <h1></h1>
    <p></p>
    <ul>
      <li></li>
      <li></li>
      <li></li>
    </ul>
  </div> //crea una lista no ordenanda anidada dentro de un <div>

3.- Agregar comentarios a JSX
	para hacerlo la sintaxis es la siguiente {/*tu comentario*/}, este puede o no estar anidado en el elemento parent
const JSX = (
  <div>
  {/*yo mama*/}
    <h1>This is a block of JSX</h1>
    <p>Here's a subtitle</p>
  </div>
);//la sintaxis con parentesis y ";" es opcional pero se considera buena practica


4.- Render elements to the DOM
	Lo que en escencia hace es presentar un elemento JSX definido con anterioridad se usa ReactDOM, que permite cargar de manera
	directa elementos de REACT a dom siguiendo la sintaxis del ejemplo
const JSX = (
  <div>
    <h1>Hello World</h1>
    <p>Lets render this to the DOM</p>
  </div>
);
// Change code below this line
ReactDOM.render(JSX, document.getElementById("challenge-node"));



5.- Definir una clase en JSX 
	Es importante dado que class en una palabra reservada en JavaScript y es por esto que es necesario escribirlo como 
	className, esto afecta a toda la sintaxis de HTML por ejemplo onclick se transforma en onClick respetando camelCase usado
	en javaScript
const JSX = (
  <div className="myDiv">
    <h1>Add a class to this div</h1>
  </div>
);

6.- Tag que se autocierran
	En HTML existen clases que se cierran solas como <br> o <hr> pero en React o existen o cambian por ejemplo  a <br/> y <hr/>
	en otros casos esto se puede usar en otras tags como <div/> que servir[ia para dibujar alg[un elemento despue[s
const JSX = (
  <div>
    <h2>Welcome to React!</h2> <br />
    <p>Be sure to close all tags!</p>
    <hr />
  </div>
);

7.- Crear  componentes de funciones sin estado 
	Se crea una funcion de React que permite manejar funciones sin estado que regresan elementos de HTML en ejemplo se ve cual
	es la sintaxis y como usar el return 
const MyComponent = function() {
  // Change code below this line
  return(
    <div>
      <p>Death is the best band in the world</p>
    </div>
  );
  // Change code above this line
}

8.- Crear un componente de React
	La manera de hacerlo es usando la sintaxis de clases de ES6 en este caso la clase que se define extiende a React.Component()
	para poder presentar los elementos que se defienen
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    // Change code below this line
  return(
    <div>
      <h1>Hello React!</h1>
    </div>
  );
    // Change code above this line
  }
};

9.- Crear un componente usando Composition
	si se tiene la situaci[on donde se necesita o se tienen definidos multiplec componentes de una app se tiene que anidar todos
	en un padre que los organice y los muestre para hacerlo llamamos el nombre la funci[on del componente como un una tag
	personalizada de HTML usando la sintaxis <mi componente/>
const ChildComponent = () => {
  return (
    <div>
      <p>I am the child</p>
    </div>
  );
};

class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>I am the parent</h1>
        { /* Change code below this line */ }
          <ChildComponent/>

        { /* Change code above this line */ }
      </div>
    );
  }
};

10.- Presentar componentes anidados
	Se usa la sitnaxis pasada para realizar anidaci[on de vario elementos de nuestra app
const TypesOfFruit = () => {
  return (
    <div>
      <h2>Fruits:</h2>
      <ul>
        <li>Apples</li>
        <li>Blueberries</li>
        <li>Strawberries</li>
        <li>Bananas</li>
      </ul>
    </div>
  );
};

const Fruits = () => {
  return (
    <div>
      { /* Change code below this line */ }
        <TypesOfFruit/>
      { /* Change code above this line */ }
    </div>
  );
};

class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* Change code below this line */ }
          <Fruits/>
        { /* Change code above this line */ }
      </div>
    );
  }
};

11.- Componentes compuesto React
	Las clases definidas usando la sintaxis ES6 se puede llamar como en el ejemplo anterior usando <miFuncion/>  ser presentada
class Fruits extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h2>Fruits:</h2>
        { /* Change code below this line */ }
          <NonCitrus/>
          <Citrus/>
        { /* Change code above this line */ }
      </div>
    );
  }
};

class TypesOfFood extends React.Component {
  constructor(props) {
     super(props);
  }
  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        { /* Change code below this line */ }
        <Fruits/>
        { /* Change code above this line */ }
        <Vegetables />
      </div>
    );
  }
};

12.- Presentar una clase de componente en DOM
	 usa la sintaxis pasada si es que hay anidaci[on y ReactDom.render, explicado en el punto 5 para presentarlo en DOM, la 
	sintaxis de la clase cambia por su definici[ion como ES6 y se tiene usar  la sintaxis <miClase/>
class TypesOfFood extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>Types of Food:</h1>
        {/* Change code below this line */}
        <Fruits/>
        <Vegetables/>
        {/* Change code above this line */}
      </div>
    );
  }
};

// Change code below this line
ReactDOM.render(<TypesOfFood/>, document.getElementById("challenge-node"));

13.- Mi primer componente
class MyComponent extends React.Component{
    constructor(props){
        super(props);
    }
    render(){
        return(
            <div>
                <h1>My First React Component!</h1>
            </div>
        );
    }
}
ReactDOM.render(<MyComponent/>, document.getElementById("challenge-node"));


14.- Pasar props a funciones stateless
	En el ejemplo se presenta informaci[on de un componente parent de un child con informaci[on de un tercero, para hacerlo
	se define la fucn[on va a necesitar un elemento como parametro, se hace desde el parent que se pasa la funci[[on con la
	info y el parametro el child da forma a esta informaci[on y el parente la presenta
const CurrentDate = (props) => {
  return (
    <div>
      { /* Change code below this line */ }
      <p>The current date is: {props.date} </p>

      
      { /* Change code above this line */ }
    </div>
  );
};

class Calendar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>What date is it?</h3>
        { /* Change code below this line */ }
        <CurrentDate date={Date()} />
        { /* Change code above this line */ }
      </div>
    );
  }
};


15.- Pasar un arreglo
	Para pasar arreglos como props estos se deben pasar siguiendo la sintaxis de JS usando {}, los metodos de los arreglos
	que existen en JavaScript est[an tambien disponibles en React 
const List = (props) => {
  { /* Change code below this line */ }
  return <p>{props.task.join(" ,")}</p>//se procesa la informaci[on se le da formato
  { /* Change code above this line */ }
};

class ToDo extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>To Do Lists</h1>
        <h2>Today</h2>
        { /* Change code below this line */ }
        <List task={["walk","dog","workout"]}/>//se pasa la informaci[on de manera cruda
        <h2>Tomorrow</h2>
        <List task={["Jomati","catalogo","Mercado","Libre"]}/>
        { /* Change code above this line */ }
      </div>
    );
  }
};

16.- Asignar un valor Default a un prop
	Se puede establecer un valor default a una prop haciendo las veces de un valor el cual usar si no se pasa ning[[un valor
	este es el que se va como el valor de props, el metodo que se usa es defaultProps()
const ShoppingCart = (props) => {
  
  return (
    <div>
      <h1>Shopping Cart Component</h1>
    </div>
  )
};
// Change code below this line
ShoppingCart.defaultProps ={
    items: 0
  }


17.- SobreEscribir un valor default
	Para hacerlo en el parent se asigna el valor de manera normal, claro respetar el tipo de valor que se pasa en el ejemplo 
	es un integro y se pasa sin comillas
const Items = (props) => {
  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
}

Items.defaultProps = {
  quantity: 0
}

class ShoppingCart extends React.Component { //valor default
  constructor(props) {
    super(props);
  }
  render() {
    { /* Change code below this line */ }
    return <Items quantity={10}/>        //se sobreescribe el valor default y se muestra el nuevo valor
    { /* Change code above this line */ }
  }
};


18.- Usar prototipos para definir props que se esperan
	Se usa propTypes del mismo modo se usa defaultProps(), la sintaxis es MyComponent.propTypes = { handleClick: PropTypes.func.isRequired }
	dentro del PropTypes se define el tipo de valor que se espera, https://reactjs.org/docs/typechecking-with-proptypes.html
	en la documentacion aparacer cuales son esto valores, al finalizar el tipo de valor o condici[on que se espera se tiene 
	que usar .isRequierd 
const Items = (props) => {
  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>
};

// Change code below this line
Items.propTypes = {
  quantity: PropTypes.number.isRequired //es este el ejemplo para un tipo de valor number
}
// Change code above this line

Items.defaultProps = {
  quantity: 0
};

class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <Items />
  }
};



19.- Accesar props usando this.props
	se usa la sintaxis dentro del child {this.props.nombreDeValor}	con esto se gana la misma funcionalidad que usando la sintaxis
	que se ha usado hasta ahora
class ReturnTempPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
            { /* Change code below this line */ }
            <p>Your temporary password is: <strong>{this.props.tempPassword}</strong></p>//se usa la sintaxis this para invocar el props
            { /* Change code above this line */ }
        </div>
    );
  }
};

class ResetPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
          <h2>Reset Password</h2>
          <h3>We've generated a new temporary password for you.</h3>
          <h3>Please reset this password from your account settings ASAP.</h3>
          { /* Change code below this line */ }
<ResetPassword tempPassword={"YoMamaDanceRegueton"}/> //se define props de manera normal en el parent
          { /* Change code above this line */ }
        </div>
    );
  }
};

20.- Resumen de uso de Prop con componentes funcionales sin estado
	Los componentes sin estado o stateless function es una companente que se comporta como una funci[on, en el caso de un
	staless functional component de React estos componente sin estado son todas las funciones que reciben un prop y regresan un JSX,
	A diferencia de un staless component es un componente que extiende React.Component, pero no tiene un estado interno.
	Un componente statfull component es un componente que s[i mantiene un estado de manera interna.
	Un patron es el de minimizar el uso de componentes con estado y maximizar el uso de componente sin estado, esto hace m[as
	sencillo seguir el estado de la aplicaci[on mantenerla y saber que est[a pasando
class CampSite extends React.Component { //componente que muestra camper
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <Camper/> //no muestra nada hasta que se le da algo que mostrar desde camper
      </div>
    );
  }
};
// Change code below this line
const Camper = props =>  <p>{props.name}</p>;//se define Camper con su props como name
	
Camper.defaultProps ={ // se define camper y su default prop, como CamperBot
  name: 'CamperBot'
};
Camper.propTypes = {
  name: PropTypes.string.isRequired//se asigna que tiene que ser un porptype de tipo String y es requerido que se cumpla
}


21.- Crear un componente con estado 
	Stateful Component
	Un estado es cualquier informaci[on que la aplicaci[on necesite saber y que pueda cambiar con el tiempo, se quiere que las
	aplicaciones reaccionen a cambios de para poder actualizar la UI 
	Para hacerlo se declara un estado dentro del constructor del componente usando la siguiente informaci[on
	thi.state = { //se describe el estado}
class StatefulComponent extends React.Component {
  constructor(props) {
    super(props);
    // Only change code below this line
    this.state= {
      name: 'The Only and Original Nacho Man Salia'
    }
    // Only change code above this line
  }
  render() {
    return (
      <div>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
};


22.- Render un estado a UI
	Lo importante de los estados es que son locales a cada componente, otros componentes no pueden ver que hacen o que son,
	se tiene que tener cuidado con esto dado que otros componentes no conocen el estado, los estados son accesibles al 
	render del componente y tiene la sintaxis <h1>{this.state.name}</h1>
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'freeCodeCamp'
    }
  }
  render() {
    return (
      <div>
        { /* Change code below this line */ }
          <h1>{this.state.name}</h1>
        { /* Change code above this line */ }
      </div>
    );
  }
};

23.- Otra forma de render estado en UI
	Se puede usar la informacion del estado antes de que se use en el return de render del componeten, realizar cualquier 
	acci[on o calculo que haga falta almacenarla en una variable y desp[ues presentar la informaci[on 
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'freeCodeCamp'
    }
  }
  render() {
    // Change code below this line
  const name = this.state.name; //variable con la informacion de state, con esta se puede cambiar o hacer lo que se quiera con ella

    // Change code above this line
    return (
      <div>
        { /* Change code below this line */ }
          <h1>{name}</h1> //se presenta la variable que se definio antes de return
        { /* Change code above this line */ }
      </div>
    );
  }
};


24.- Establecer un estado usando setState
	La funci[on setState responde a una accion por ejemplo a que se presione un boton, dentro de ella se puede y se cambia el
	valor del estado siguiendo la sintaxis de props y variable que se ha visto {name: "React"}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'Initial State'
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    // Change code below this line
  this.setState({name: "React Rocks!"})
    // Change code above this line
  }
  render() {
    return (
      <div>
        <button onClick={this.handleClick}>Click Me</button>
        <h1>{this.state.name}</h1>
      </div>
    );
  }
};

25.- Bind para this a un metodo de la clase
	this se refiere en este contexto al companente, pero para que un metodo use this tenemos que ligarlo (bind) a ese metodo
	this.handleClick = this.handleClick.bind(this), se establece que this.handleClick se acciona sobre this estan ligados
	en el ejemplo con dar un click
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      text: "Hello"
    };
    // Change code below this line
  this.handleClick = this.handleClick.bind(this)//se liga this con la accion del componente handleClick
    // Change code above this line
  }
  handleClick() {
    this.setState({
      text: "You clicked!"
    });
  }
  render() {
    return (
      <div>
        { /* Change code below this line */ }
        <button onClick={this.handleClick}>Click Me</button>//se liga la accion del boton con this.handleClick
        { /* Change code above this line */ }
        <h1>{this.state.text}</h1>
      </div>
    );
  }
};

26.- Usar estado de Toggle un element

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      visibility: false
    };
    // Change code below this line
    this.toggleVisibility = this.toggleVisibility.bind(this); //dentro del constructor se define a que funciona se liga this
    // Change code above this line
  }
  // Change code below this line
    toggleVisibility(){           //saliendo del construct, se define esta funcion y que hace la logica es similar a javascript
      this.setState(state => {    //pero se tiene que respetar el manejo de las variables con {} para hacer el return 
        if(state.visibility === true){
          return { visibility: false}
        } else {
          return {visibility: true}
        }
      });
    }

  // Change code above this line
  render() {
    if (this.state.visibility) {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
          <h1>Now you see me!</h1>
        </div>
      );
    } else {
      return (
        <div>
          <button onClick={this.toggleVisibility}>Click Me</button>
        </div>
      );
    }
  }
}


27.- Hacer bind de estado a varias funciones
	En el ejemplo se extiendo lo que se ha hecho en los ejemplo anteriores y se muestra que this se puede casar con varias
	funciones y hacer cambios a la que aparece en la pantalla
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
    // Change code below this line
  this.increment = this.increment.bind(this);
  this.decrement = this.decrement.bind(this);
  this.reset = this.reset.bind(this);
    // Change code above this line
  }
  // Change code below this line
  increment(){
    this.setState(state => ({
      count: state.count + 1
    }));
  }
  decrement(){
    this.setState(state => ({
      count: state.count - 1
    }))
  }
  reset(){
    this.setState(state => ({
      count: state.count = 0
    }))
  }
  // Change code above this line
  render() {
    return (
      <div>
        <button className='inc' onClick={this.increment}>Increment!</button>
        <button className='dec' onClick={this.decrement}>Decrement!</button>
        <button className='reset' onClick={this.reset}>Reset</button>
        <h1>Current Count: {this.state.count}</h1>
      </div>
    );
  }
};


28.- Ejemplo de cambio de UI al momento de que pasa
	en este caso se crea una funci[on que liga uno a uno la entrada de datos a la actualizaci[on del UI
class ControlledInput extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: ''
    };
    // Change code below this line
    this.handleChange = this.handleChange.bind(this)
    // Change code above this line
  }
  // Change code below this line
  handleChange(event){
    this.setState({
      input: event.target.value
    })
  }
  // Change code above this line
  render() {
    return (
      <div>
        { /* Change code below this line */}
      <input value = {this.state.input} onChange = {this.handleChange}/>
        { /* Change code above this line */}
        <h4>Controlled Input:</h4>
        <p>{this.state.input}</p>
      </div>
    );
  }
};


29.- Crear una forma controlada
	?Que significa esto? significa que se usa un state para almacenar informaci[on y adem[as de eso agregar esa informaci[on 
	en otro state y presentar la informaci[on, 
class MyForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '', //almacena la variabale el cambio del input que maneja el boton
      submit: '' //este valor recibe el valor de input y lo agrega en el h1
    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleChange(event) {
    this.setState({
      input: event.target.value
    });
  }
  handleSubmit(event) {
    // Change code below this line
    event.preventDefault() //evitar el valor default se guarde sobre el input
      this.setState({
        submit: this.state.input //este valor es el que actualiza la boton
      })
    
    // Change code above this line
  }
  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          {/* Change code below this line */}
            <input 
              value = {this.state.input}
              onChange = {this.handleChange} //al presionar el boton se guarda el valor del input y se actualiza la variable
            />  			     //de submit
          {/* Change code above this line */}
          <button type='submit'>Submit!</button>
        </form>
        {/* Change code below this line */}
            <h1>{this.state.submit}</h1>
        {/* Change code above this line */}
      </div>
    );
  }
}


30.- Pasar un state a un componente child
	Se tiene que definir dentro del parente <Child/> despu[es pasar el estado como prop <Child {this.state.name}/> para pasar
	estado se tiene que usa la palabra this
	Del lado del child se tiene que usar la sintaxis <h1>This is a parent state : {this.props.name}</h1> donde this hace refe-
	rencia al child donde props ahora tiene el valor del state del parent
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'CamperBot'
    }
  }
  render() {
    return (
       <div>
         {/* Change code below this line */}
         <Navbar name={this.state.name} />
         {/* Change code above this line */}
       </div>
    );
  }
};

class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
    <div>
      {/* Change code below this line */}
      <h1>Hello, my name is: {this.props.name} </h1>
      {/* Change code above this line */}
    </div>
    );
  }
};

31.- Pasar un Callback (funcion) como prop
	En este ejemplo se pasa un state a un child y una funcion, el resultado de la funci[on regresa al parent que contiene 
	el metodo que realiza la acci[on, este nuevo estado pasa a un segundo child que presenta la informaci[on trabajada
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: ''
    }
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({
      inputValue: event.target.value
    });
  }
  render() {
    return (
       <div>
        { /* Change code below this line */ }
        <GetInput 
        input={this.state.inputValue} //state original
	handleChange={this.handleChange}/>//metodo que cambia el state
        <RenderInput 
        input={this.state.inputValue}/>//resultado del state despues de pasar por el metodo
        { /* Change code above this line */ }
       </div>
    );
  }
};

class GetInput extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>Get Input:</h3>
        <input
          value={this.props.input} //input del state
          onChange={this.props.handleChange}/>//metodo casado con el state que presenta la informacion
      </div>
    );
  }
};

class RenderInput extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>Input Render:</h3>
        <p>{this.props.input}</p> //presenta el resultado del metodo handleChange()
      </div>
    );
  }
};

32.- componentWillMount
	En este caso est[a funci[on es usanda antes del render() para poder dejar claro, o presentar algo en la consola por ejemplo otros metodos son componentDidMount() shouldComponentUpdate() componentDidUpdate() componentWillUnmount()
	estos componentes son usados en diferentes momentos del lifycycle
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  componentWillMount() {
    // Change code below this line
    console.log("yo mama")
    // Change code above this line
  }
  render() {
    return <div />
  }
};

33.- Metodo componentDidMount()
	Este metodo vive antes de render(), es usado en los caso que se hace un llamado a un API de servidor externo dado que su
	funci[on es actualizar informaic[on, cual quier llamado a setState() en este metodo va a disparar una recarga del render
	con la informaci[on que se obtiene
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeUsers: null
    };
  }
  componentDidMount() {
    setTimeout(() => { //esta funcii[on actualiza el valor de active users
      this.setState({
        activeUsers: 1473
      });
    }, 3500); //tiene una espera de 3500 milisegundos para hacerlo
  }
  render() {
    return (  
      <div>
        {/* Change code below this line */}
        <h1>Active Users: {this.state.activeUsers} </h1> //cuando el cambio se alcanza se presenta el nuevo valor del state acutal
        {/* Change code above this line */}
      </div>
    );
  }
}

34.- Agregar monitor de Eventos
	usando componentDidMount y componentWillMount se tiene que se puede agregar estos "monitores" listeners ha diferentes 
	momentos del lifecylce desde que ya se monto a la promesa que lo va hacer
	En el ejemplo se hace un listener a la funci[on handleKeyPress() en ella se tiene un par de condiciones que cambian el valor
	message dentro del state, handleEnter lo que hace es manejar cuando se presiona Enter, como juego agrege una condici[on que
	maneja cuando se presiona la letra b
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: ''
    };
    this.handleEnter = this.handleEnter.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
  }
  // Change code below this line
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyPress)
  }
  componentWillUnmount() {
    document.removeEventListener("keydown",this.handleKeyPress)
  }
  // Change code above this line
  handleEnter() {
    this.setState((state) => ({
      message: state.message + 'You pressed the enter key! '
    }));
  }
  handleKeyPress(event) {
    if (event.keyCode === 13) {
      this.handleEnter();
    }else if(event.keyCode === 66){
      this.setState((state) =>({
        message: state.message + "this is a b"
      }));
    }
  }
  render() {
    return (
      <div>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
};


35.- Metodo shouldComponentUpdate()
	Es un metodo para verificar si se debe o no re-render la pantalla toma 2 parametros uno nextProps y nectState, el comporta-
	miento default es que se actualice o se re-render cada vez que se se recive un nuevo props su valor halla cambiado o no
	para hacerlo recive 2 parametros nextProps, el nuevo props y nextState el nuevo state con esto se puede jugar y crear 
	cosas muy interesantes por ejemplo, en el ejemplo s[olo se re-render cuando props es diferente de nextProps y el valor
	de nextProps es par
	
class OnlyEvens extends React.Component {
  constructor(props) {
    super(props);
  }
  shouldComponentUpdate(nextProps, nextState) {
    console.log('Should I update?');
    // Change code below this line
    if(this.props != nextProps && (nextProps.value % 2) === 0){ //si se cumple la condici[on se regresa true lo que permite que
								//react re-render la pantalla de lo contrario nada cambia
      console.log(nextProps.value)
      
      return true;
    }
    // Change code above this line
  }
  componentDidUpdate() {
    console.log('Component re-rendered.');
  }
  render() {
    return <h1>{this.props.value}</h1>;
  }
}

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 0
    };
    this.addValue = this.addValue.bind(this);
  }
  addValue() {
    this.setState(state => ({
      value: state.value + 1
    }));
  }
  render() {
    return (
      <div>
        <button onClick={this.addValue}>Add</button>
        <OnlyEvens value={this.state.value} />
      </div>
    );
  }
}

36.- Introducci[on a estilos en linea
     Inline Styles
	Se puede usar e importar los estilos desde un stylesheet como com[unmente se hace en un documento de HTML pero si es necesario
	o es practica com[un en React los estilos se pueden aplicar en la linea que se declaran 
	Se tiene que tener mucho cuidado con la nueva sintaxis style={{color:"red", fontSize:"72px"}} doble {} y uso de camelCase
	para las propiedades de CSS que sean de dos o m[as palabras, los valores de las propiedades se tiene que pasar como strings
class Colorful extends React.Component {
  render() {
    return (
      <div style={{color:"red", fontSize:"72px"}}>Big Red</div>
    );
  }
};


37.- M[as cambios en los estilos inline
	Todos los valores de height, width o fontSize (correcta sintaxis) se asumen en px, todos los valores se deden especificar y
	adem[as de eso se tiene que especificar por ejemplo {fontSize: "40em"}
	Junto a esto se gana la capacidad de manajer los estilos como constantes como se ve en el ejemplo est[as contastes se 
	declaran fuera de las funciones y se puede asignar al style del elemento dentro de render()
 // Change code above this line
  const styles ={
    color: "purple",
    fontSize: "40",
    border: "2px solid purple"
  }
class Colorful extends React.Component {
  render() {
    // Change code below this line
    return (
      
      <div style={styles}>Style Me!</div>
    );
    // Change code above this line
  }
};


38.- Usar JavaScript avanzado en m[etodo Render
	Para hacerlo se puede implementar javascript directo de el metodo render, en el ejemplo se imita el juguete de la bola
	8 de predicciones, dentro de render se tiene un arreglo que contiene una serie de posibles respuestas, dentro de 
	render se declara una nueva variable answer que es igual a una de estas repuestas, pero se selecciona al azar ccon el
	m[etodo ask, que es llamdao cuando se presiona el boton al hacerlo se valida si es que se ingreso algo en el input, de ser
	as[i llama a y dentro de este metodo se usar Math.random() *20 y genera un numero entero aleatorio que se usa para el
	index de possibleAnswer
const inputStyle = {
  width: 235,
  margin: 5
};

class MagicEightBall extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userInput: '',
      randomIndex: ''
    };
    this.ask = this.ask.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  ask() {
    if (this.state.userInput) {
      this.setState({
        randomIndex: Math.floor(Math.random() * 20),
        userInput: ''
      });
    }
  }
  handleChange(event) {
    this.setState({
      userInput: event.target.value
    });
  }
  render() {
    const possibleAnswers = [
      'It is certain',
      'It is decidedly so',
      'Without a doubt',
      'Yes, definitely',
      'You may rely on it',
      'As I see it, yes',
      'Outlook good',
      'Yes',
      'Signs point to yes',
      'Reply hazy try again',
      'Ask again later',
      'Better not tell you now',
      'Cannot predict now',
      'Concentrate and ask again',
      "Don't count on it",
      'My reply is no',
      'My sources say no',
      'Most likely',
      'Outlook not so good',
      'Very doubtful'
    ];
    const answer = possibleAnswers[this.state.randomIndex]; // Change this line
    return (
      <div>
        <input
          type='text'
          value={this.state.userInput}
          onChange={this.handleChange}
          style={inputStyle}
        />
        <br />
        <button onClick={this.ask}>Ask the Magic Eight Ball!</button>
        <br />
        <h3>Answer:</h3>
        <p>
          {/* Change code below this line */}
          {answer}
          {/* Change code above this line */}
        </p>
      </div>
    );
  }
}


39.- Render con If else condition
	Se usa como un if else normal mientras que se use afuera de un elemento HTML de render como en el ejemplo
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true
    }
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }
  toggleDisplay() {
    this.setState((state) => ({
      display: !state.display
    }));
  }
  render() {
    // Change code below this line
  if(this.state.display){
       return (
       <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
           <h1>Displayed!</h1>
         
       </div>
    );
  } else {
    return(
                 <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
         </div>
    )

  }
 
  }
};


40.- Usar && como condicion
	Es una condición que usa la sintaxis de {} para llamar funciones de javascript dentro de un elemento de HTML, en este caso
	se tiene que se usa una condici[on como esta {this.state.evaluar && <h1>Me veo o no</h1>} el && hace las veces de if
	En este caso y evalua y si se cumple entonces se presenta el elemento html de otro modo no lo hace
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true
    }
    this.toggleDisplay = this.toggleDisplay.bind(this);
  }
  toggleDisplay() {
    this.setState(state => ({
      display: !state.display
    }));
  }
  render() {
    // Change code below this line
    return (
       <div>
         <button onClick={this.toggleDisplay}>Toggle Display</button>
         {this.state.display && <h1>Displayed!</h1>}
         {!this.state.display && <h1>¡A Chinga se fue!</h1>}
       </div>
    );
  }
};


